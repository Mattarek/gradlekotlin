### Wzorce projektowe ###
	# Wzorce Kreacyjne #
	1. Singleton
		# Kategoria: Kreacyjny
		# Problem, ktÃ³ry rozwiÄ…zuje
			Singleton rozwiÄ…zuje problem, gdy w systemie musi istnieÄ‡ dokÅ‚adnie jeden obiekt danej klasy, a jednoczeÅ›nie potrzebny jest
			  globalny punkt dostÄ™pu do tego obiektu. Typowe przykÅ‚ady:
				- MenedÅ¼er konfiguracji (Configuration Manager)
				- Logger (logowanie aplikacji)
				- PoÅ‚Ä…czenie z bazÄ… danych (Database Connection Pool, choÄ‡ zwykle bardziej zaawansowane)

		# Bez Singletona kaÅ¼dy moduÅ‚ mÃ³gÅ‚by tworzyÄ‡ wÅ‚asnÄ… instancjÄ™, co prowadziÅ‚oby do:
			- NiespÃ³jnych danych (np. rÃ³Å¼ne konfiguracje w rÃ³Å¼nych instancjach)
			- Nadmiernego zuÅ¼ycia pamiÄ™ci
			- ProblemÃ³w w synchronizacji przy wspÃ³Å‚bieÅ¼nym dostÄ™pie

			# Implementacje w Javie
				1. Prosty Singleton (bez bezpieczeÅ„stwa wÄ…tkowego)
					# Uwagi:
						- Prosty i szybki, niebezpieczny w Å›rodowisku wielowÄ…tkowym.
						- Dwa wÄ…tki mogÄ… utworzyÄ‡ dwa rÃ³Å¼ne obiekty, jeÅ›li wywoÅ‚ajÄ… getInstance() rÃ³wnoczeÅ›nie.

					# Kod
						public class Singleton {
						    private static Singleton instance;

						    private Singleton() {} // prywatny konstruktor

						    public static Singleton getInstance() {
						        if (instance == null) {
						            instance = new Singleton();
						        }
						        return instance;
						    }
						}

				2. Thread-safe Singleton (synchronizacja)
					# Kod
						public class Singleton {
						    private static Singleton instance;

						    private Singleton() {}

						    public static synchronized Singleton getInstance() {
						        if (instance == null) {
						            instance = new Singleton();
						        }
						        return instance;
					    	}
						}

					# Uwagi:
						- Synchronizacja gwarantuje bezpieczeÅ„stwo wÄ…tkowe.
						- Minusem jest spadek wydajnoÅ›ci, bo kaÅ¼dy dostÄ™p blokuje metodÄ™.

				3. Double-checked Locking (optymalna wersja wÄ…tkowa)
					# Kod
						public class Singleton {
						    private static volatile Singleton instance;

						    private Singleton() {}

						    public static Singleton getInstance() {
						        if (instance == null) { // pierwszy test
						            synchronized (Singleton.class) {
						                if (instance == null) { // drugi test
						                    instance = new Singleton();
						                }
						            }
						        }
						        return instance;
						    }
						}

					# Uwagi:
						- Kombinacja blokady i podwÃ³jnego sprawdzenia.
						- SÅ‚owo kluczowe volatile zapobiega problemom z widocznoÅ›ciÄ… zmian miÄ™dzy wÄ…tkami.
						- NajczÄ™Å›ciej stosowane w systemach wielowÄ…tkowych.

				4. Singleton przy uÅ¼yciu Enum
					# Kod - Enum
						import java.sql.Connection;
						import java.sql.DriverManager;
						import java.sql.SQLException;

						public enum DatabaseConnection {
						    INSTANCE;

						    private Connection connection;

						    // Konstruktor enum â€“ wywoÅ‚ywany tylko raz
						    DatabaseConnection() {
						        try {
						            String url = "jdbc:mysql://localhost:3306/mydb";
						            String user = "root";
						            String password = "password";
						            connection = DriverManager.getConnection(url, user, password);
						            System.out.println("PoÅ‚Ä…czenie z bazÄ… utworzone");
						        } catch (SQLException e) {
						            e.printStackTrace();
						        }
						    }

						    // Publiczna metoda do pobrania poÅ‚Ä…czenia
						    public Connection getConnection() {
						        return connection;
						    }
						}

					# Main
						import java.sql.Connection;
						import java.sql.ResultSet;
						import java.sql.Statement;

						public class Main {
						    public static void main(String[] args) {
						        try {
						            Connection conn = DatabaseConnection.INSTANCE.getConnection();
						            Statement stmt = conn.createStatement();
						            ResultSet rs = stmt.executeQuery("SELECT * FROM users");

						            while (rs.next()) {
						                System.out.println("User: " + rs.getString("username"));
						            }
						        } catch (Exception e) {
						            e.printStackTrace();
						        }
						    }
						}


						# Uwagi:
							- Najbezpieczniejsza implementacja w Javie (serializacja i refleksja nie Å‚amiÄ… wzorca).
							- Bardzo prosty kod, gwarantuje pojedynczÄ… instancjÄ™.

			# Zalety Singletona
				- Globalny dostÄ™p do instancji.
				- Kontrola nad tworzeniem obiektu.
				- OszczÄ™dnoÅ›Ä‡ pamiÄ™ci â€“ tylko jedna instancja.

			# Wady / puÅ‚apki
				- Trudne testowanie jednostkowe (mockowanie wymaga dodatkowych trikÃ³w).
				- MoÅ¼e prowadziÄ‡ do ukrytych zaleÅ¼noÅ›ci w kodzie (tzw. â€œglobal stateâ€).
				- Nadmierne uÅ¼ycie moÅ¼e powodowaÄ‡ problemy z projektowaniem (krytyczny punkt sprzÄ™Å¼enia w systemie).

			# Eager Singleton vs Lazy Singleton
				# Eager Singleton (chÄ™tny â€“ od razu tworzony)
					- Instancja Singletona jest tworzona od razu, przy zaÅ‚adowaniu klasy.
					- Jest proste i thread-safe bez dodatkowej synchronizacji.
						# Kod
						class EagerSingleton {
						    private static final EagerSingleton INSTANCE = new EagerSingleton();

						    private EagerSingleton() {}

						    public static EagerSingleton getInstance() {
						        return INSTANCE;
						    }
						}

					Zalety:
						- Proste, bez synchronizacji.
						- Instancja zawsze gotowa do uÅ¼ycia.

					Wady:
						- Tworzony od razu, nawet jeÅ›li nigdzie nie jest uÅ¼ywany â†’ moÅ¼e byÄ‡ marnotrawstwo pamiÄ™ci.

				# Lazy Singleton (leniwy â€“ tworzony dopiero przy potrzebie)
					- Instancja jest tworzona dopiero przy pierwszym wywoÅ‚aniu getInstance().
					- Wymaga synchronizacji w wersji wielowÄ…tkowej.
						# Kod
							class LazySingleton {
							    private static LazySingleton instance;

							    private LazySingleton() {}

							    public static synchronized LazySingleton getInstance() {
							        if (instance == null) {
							            instance = new LazySingleton();
							        }
							        return instance;
							    }
							}

					Zalety:
						- OszczÄ™dnoÅ›Ä‡ zasobÃ³w â€“ instancja tworzona tylko jeÅ›li potrzebna.

					Wady:
						- Synchronizacja moÅ¼e wprowadzaÄ‡ lekkie opÃ³Åºnienie (moÅ¼na uÅ¼yÄ‡ â€double-checked lockingâ€ dla optymalizacji).



	2. Builder
		# Kategoria: Kreacyjny
		# Problem, ktÃ³ry rozwiÄ…zuje
			# Builder rozwiÄ…zuje problem, gdy:
				- Tworzymy skomplikowane obiekty z wieloma polami.
				- NiektÃ³re pola sÄ… opcjonalne, inne obowiÄ…zkowe.
				- Chcemy uniknÄ…Ä‡ dÅ‚ugich konstruktorÃ³w (tzw. â€œtelescoping constructorsâ€), ktÃ³re sÄ… trudne w uÅ¼yciu i czytelnoÅ›ci.

			# Typowe przykÅ‚ady:
				- Tworzenie obiektu Car z wieloma opcjami wyposaÅ¼enia.
				- Konfigurowanie obiektÃ³w HTTP Request lub UI Component.

			# Bez Buildera:
				- CiÄ™Å¼ko zrozumieÄ‡ co kaÅ¼dy parametr oznacza:
					Car car = new Car("Toyota", "Corolla", "czerwony", 4, true, false, null);

		# RozwiÄ…zanie
			- Oddzielamy konstrukcjÄ™ obiektu od jego reprezentacji.
			- Tworzymy wewnÄ™trznÄ… klasÄ™ Builder, ktÃ³ra stopniowo ustawia pola i tworzy finalny obiekt.
			- Daje czytelny i elastyczny kod, ktÃ³ry moÅ¼na rozszerzaÄ‡ bez zmiany istniejÄ…cych konstruktorÃ³w.

		# Implementacja w Javie
			public class Car {
			    // Pola obiektu
			    private final String brand;     // obowiÄ…zkowe
			    private final String model;     // obowiÄ…zkowe
			    private final String color;     // opcjonalne
			    private final int doors;        // opcjonalne
			    private final boolean sunroof;  // opcjonalne
			    private final boolean gps;      // opcjonalne

			    // Prywatny konstruktor â€“ tylko Builder moÅ¼e go wywoÅ‚aÄ‡
			    private Car(Builder builder) {
			        this.brand = builder.brand;
			        this.model = builder.model;
			        this.color = builder.color;
			        this.doors = builder.doors;
			        this.sunroof = builder.sunroof;
			        this.gps = builder.gps;
			    }

			    // Gettery do pÃ³l
			    public String getBrand() { return brand; }
			    public String getModel() { return model; }
			    public String getColor() { return color; }

			    // Klasa Builder
			    public static class Builder {
			        private final String brand;
			        private final String model;
			        private String color = "black"; // domyÅ›lna wartoÅ›Ä‡
			        private int doors = 4;           // domyÅ›lna wartoÅ›Ä‡
			        private boolean sunroof = false;
			        private boolean gps = false;

			        // Konstruktor Builder z polami obowiÄ…zkowymi
			        public Builder(String brand, String model) {
			            this.brand = brand;
			            this.model = model;
			        }

			        // Metody ustawiajÄ…ce pola opcjonalne
			        public Builder color(String color) { this.color = color; return this; }
			        public Builder doors(int doors) { this.doors = doors; return this; }
			        public Builder sunroof(boolean sunroof) { this.sunroof = sunroof; return this; }
			        public Builder gps(boolean gps) { this.gps = gps; return this; }

			        // Metoda budujÄ…ca obiekt
			        public Car build() {
			            return new Car(this);
			        }
			    }

			    @Override
			    public String toString() {
			        return brand + " " + model + " (" + color + "), doors: " + doors +
			               ", sunroof: " + sunroof + ", GPS: " + gps;
			    }
			}

		# UÅ¼ycie w praktyce
			public class Main {
			    public static void main(String[] args) {
			        Car car1 = new Car.Builder("Toyota", "Corolla")
			                            .color("red")
			                            .sunroof(true)
			                            .gps(true)
			                            .build();

			        Car car2 = new Car.Builder("Honda", "Civic")
			                            .doors(2)
			                            .build();

			        System.out.println(car1);
			        System.out.println(car2);
			    }
			}

			# Zalety Buildera
				- Czytelny kod, szczegÃ³lnie przy wielu opcjonalnych polach.
				- MoÅ¼liwoÅ›Ä‡ Å‚atwej rozbudowy obiektu w przyszÅ‚oÅ›ci.
				- Bezpieczny â€“ pola finalne w obiekcie mogÄ… byÄ‡ ustawione tylko raz.
				- Unika â€œtelescoping constructorsâ€ i bÅ‚Ä™dÃ³w w kolejnoÅ›ci parametrÃ³w.

			# Wady / puÅ‚apki
				- TrochÄ™ wiÄ™cej kodu niÅ¼ przy prostych konstruktorach.
				- Nadmierne uÅ¼ycie Buildera przy prostych obiektach moÅ¼e byÄ‡ przesadÄ….



	3. Factory Method
		# Kategoria: Kreacyjny
			# Problem, ktÃ³ry rozwiÄ…zuje
				- W systemach, gdzie tworzenie obiektÃ³w jest skomplikowane lub zaleÅ¼ne od kontekstu, czÄ™sto nie chcemy, aby klient
					znaÅ‚ dokÅ‚adnÄ… klasÄ™ tworzonego obiektu.
				- Chcemy odseparowaÄ‡ logikÄ™ tworzenia obiektÃ³w od ich uÅ¼ycia.

			# Typowe sytuacje:
				- Tworzenie rÃ³Å¼nych typÃ³w dokumentÃ³w (PDF, Word, Excel) w zaleÅ¼noÅ›ci od potrzeb.
				- Tworzenie rÃ³Å¼nych typÃ³w powiadomieÅ„ (Email, SMS, Push).
				- Systemy wtyczek / rozszerzeÅ„, gdzie dokÅ‚adny typ obiektu nie jest znany w momencie kompilacji.

			# Bez Factory Method:
				- Kod klienta jest Å›ciÅ›le powiÄ…zany z konkretnymi klasami â†’ trudny do rozszerzenia.
					if(type.equals("pdf")) doc = new PdfDocument();
					else if(type.equals("word")) doc = new WordDocument();

			# RozwiÄ…zanie
				- Tworzymy fabrykÄ™ (Factory), ktÃ³ra decyduje, ktÃ³rÄ… klasÄ™ utworzyÄ‡.
				- Klient uÅ¼ywa interfejsu lub klasy abstrakcyjnej, a fabryka tworzy konkretnÄ… instancjÄ™.
				- Pozwala to na Å‚atwe rozszerzanie systemu bez zmiany kodu klienta.

			# Implementacja w Javie
				Krok 1: Interfejs produktu
					// Produkt
					interface Notification {
					    void notifyUser();
					}

				Krok 2: Konkretne produkty
					class SMSNotification implements Notification {
					    public void notifyUser() {
					        System.out.println("Sending SMS notification");
					    }
					}

					class EmailNotification implements Notification {
					    public void notifyUser() {
					        System.out.println("Sending Email notification");
					    }
					}

					class PushNotification implements Notification {
					    public void notifyUser() {
					        System.out.println("Sending Push notification");
					    }
					}

				# Krok 3: Abstrakcyjna fabryka
					abstract class NotificationFactory {
					    public abstract Notification createNotification();
					}

				# Krok 4: Konkretne fabryki
					class SMSNotificationFactory extends NotificationFactory {
					    public Notification createNotification() {
					        return new SMSNotification();
					    }
					}

					class EmailNotificationFactory extends NotificationFactory {
					    public Notification createNotification() {
					        return new EmailNotification();
					    }
					}

					class PushNotificationFactory extends NotificationFactory {
					    public Notification createNotification() {
					        return new PushNotification();
					    }
					}

			# Zalety Factory Method
				- Odseparowanie tworzenia od uÅ¼ycia â€“ klient nie zna konkretnych klas.
				- Åatwe rozszerzanie â€“ dodanie nowego typu produktu wymaga tylko stworzenia nowej fabryki i klasy produktu.
				- Polimorfizm â€“ klient uÅ¼ywa tylko interfejsu / abstrakcji.

			# Wady / puÅ‚apki
			 	- Wzorzec moÅ¼e generowaÄ‡ duÅ¼Ä… liczbÄ™ klas fabryk, jeÅ›li produktÃ³w jest duÅ¼o.
			 	- Czasem prostszy Builder lub prosty warunek if wystarcza dla niewielkich systemÃ³w.




	4. Abstract Factory
		## Kategoria: Kreacyjny
			# Problem, ktÃ³ry rozwiÄ…zuje
				- Kiedy aplikacja musi tworzyÄ‡ rodziny powiÄ…zanych obiektÃ³w, ale nie chce znaÄ‡ konkretnych klas tych obiektÃ³w.
				- Chcemy zapewniÄ‡ spÃ³jnoÅ›Ä‡ miÄ™dzy powiÄ…zanymi obiektami (np. wszystkie GUI elementy w tym samym stylu).

			# Typowe przykÅ‚ady:
				- System GUI, gdzie moÅ¼na tworzyÄ‡ przyciski i pola tekstowe w stylu Windows, macOS lub Linux.
				- Tworzenie obiektÃ³w dla rÃ³Å¼nych baz danych (np. MySQL, PostgreSQL) â€“ Connection + Command + Transaction.
				- Systemy, gdzie dodanie nowej rodziny obiektÃ³w nie wymaga zmian w kodzie klienta.

			# Bez Abstract Factory:
				- Kod klienta jest Å›ciÅ›le powiÄ…zany z konkretnymi klasami, trudny do zmiany stylu lub bazy.
					Button button = new WindowsButton();
					TextField tf = new WindowsTextField();

			# RozwiÄ…zanie
				- Tworzymy interfejs abstrakcyjnej fabryki, ktÃ³ry definiuje metody tworzenia wszystkich produktÃ³w z jednej rodziny.
				- KaÅ¼da konkretna fabryka implementuje ten interfejs dla swojej rodziny produktÃ³w.
				- Klient uÅ¼ywa tylko interfejsu fabryki i interfejsÃ³w produktÃ³w â†’ nie zna szczegÃ³Å‚Ã³w implementacji.

		# Implementacja w Javie
			# Krok 1: Interfejsy produktÃ³w
				interface Button {
				    void paint();
				}

				interface TextField {
				    void render();
				}

			# Krok 2: Konkretne produkty
				// Windows
				class WindowsButton implements Button {
				    public void paint() {
				        System.out.println("Drawing Windows Button");
				    }
				}

				class WindowsTextField implements TextField {
				    public void render() {
				        System.out.println("Rendering Windows TextField");
				    }
				}

				// MacOS
				class MacButton implements Button {
				    public void paint() {
				        System.out.println("Drawing Mac Button");
				    }
				}

				class MacTextField implements TextField {
				    public void render() {
				        System.out.println("Rendering Mac TextField");
				    }
				}

			# Krok 3: Abstrakcyjna fabryka
				interface GUIFactory {
				    Button createButton();
				    TextField createTextField();
				}

			# Krok 4: Konkretne fabryki
				class WindowsFactory implements GUIFactory {
				    public Button createButton() { return new WindowsButton(); }
				    public TextField createTextField() { return new WindowsTextField(); }
				}

				class MacFactory implements GUIFactory {
				    public Button createButton() { return new MacButton(); }
				    public TextField createTextField() { return new MacTextField(); }
				}

			# UÅ¼ycie w praktyce
				public class Main {
				    public static void main(String[] args) {
				        GUIFactory factory;

				        // Tworzymy GUI w stylu Windows
				        factory = new WindowsFactory();
				        Button winButton = factory.createButton();
				        TextField winText = factory.createTextField();
				        winButton.paint();
				        winText.render();

				        // Tworzymy GUI w stylu MacOS
				        factory = new MacFactory();
				        Button macButton = factory.createButton();
				        TextField macText = factory.createTextField();
				        macButton.paint();
				        macText.render();
				    }
				}

			# Zalety Abstract Factory
				- Zapewnia spÃ³jnoÅ›Ä‡ produktÃ³w z jednej rodziny.
				- Klient nie zna klas konkretnych produktÃ³w, tylko interfejsy.
				- Åatwe rozszerzenie o nowÄ… rodzinÄ™ produktÃ³w (np. Linux GUI).
				- UÅ‚atwia zarzÄ…dzanie duÅ¼ymi systemami z wieloma wariantami obiektÃ³w.

			# Wady / puÅ‚apki
				- Tworzy wiÄ™cej klas â€“ kaÅ¼da rodzina obiektÃ³w wymaga osobnej fabryki.
				- MoÅ¼e byÄ‡ przesadÄ… dla maÅ‚ych projektÃ³w.

	5. Prototype
		# Kategoria: Kreacyjny
			# Problem, ktÃ³ry rozwiÄ…zuje
				- Kiedy tworzenie nowych obiektÃ³w jest kosztowne (czasowo lub pamiÄ™ciowo) i chcemy tworzyÄ‡ kopie istniejÄ…cych obiektÃ³w zamiast tworzyÄ‡ je od zera.
				- Kiedy chcemy mieÄ‡ dynamicznÄ… konfiguracjÄ™ obiektÃ³w w runtime, bez twardego kodowania klas.

			# Typowe przykÅ‚ady:
				- Tworzenie kopii skomplikowanych obiektÃ³w konfiguracyjnych.
				- Obiekty w grach (np. przeciwnicy lub elementy planszy), ktÃ³re rÃ³Å¼niÄ… siÄ™ tylko kilkoma wÅ‚aÅ›ciwoÅ›ciami.
				- Klonowanie dokumentÃ³w, zamÃ³wieÅ„ lub widgetÃ³w w GUI.

			# Bez Prototype:
				- Trzeba tworzyÄ‡ wszystko od nowa â†’ kosztowne i powtarzalne.
				# Kod
					Document doc1 = new Document(...);
					Document doc2 = new Document(...);

			# RozwiÄ…zanie
				- Tworzymy interfejs Prototype z metodÄ… clone().
				- KaÅ¼dy obiekt implementuje clone() i zwraca kopiÄ™ samego siebie.
				- MoÅ¼na w ten sposÃ³b Å‚atwo tworzyÄ‡ nowe obiekty na podstawie istniejÄ…cych.

			# Implementacja w Javie
				- Krok 1: Interfejs Prototype
					interface Prototype extends Cloneable {
					    Prototype clone();
					}

				- Krok 2: Konkretna klasa
					class Document implements Prototype {
					    private String title;
					    private String content;

					    public Document(String title, String content) {
					        this.title = title;
					        this.content = content;
					    }

					    // Implementacja klonowania
					    @Override
					    public Prototype clone() {
					        return new Document(this.title, this.content);
					    }

					    @Override
					    public String toString() {
					        return "Document [title=" + title + ", content=" + content + "]";
					    }
					}

				- UÅ¼ycie w praktyce
					public class Main {
					    public static void main(String[] args) {
					        Document original = new Document("Plan projektu", "TreÅ›Ä‡ planu projektu...");

					        // Tworzymy kopiÄ™ obiektu zamiast tworzyÄ‡ od nowa
					        Document copy = (Document) original.clone();

					        System.out.println(original);
					        System.out.println(copy);

					        // Sprawdzamy, czy to rÃ³Å¼ne obiekty
					        System.out.println(original == copy); // false
					    }
					}


			# Zalety Prototype
				- Szybkie tworzenie obiektÃ³w â€“ kopiowanie zamiast tworzenia od zera.
				- ElastycznoÅ›Ä‡ â€“ moÅ¼na dynamicznie tworzyÄ‡ rÃ³Å¼ne obiekty w runtime.
				- Unika twardego kodowania â€“ nowe obiekty mogÄ… powstawaÄ‡ z juÅ¼ istniejÄ…cych.

			# Wady / puÅ‚apki
				- Powierzchowne klonowanie (shallow copy) moÅ¼e powodowaÄ‡ dzielenie referencji do obiektÃ³w wewnÄ™trznych â€“ w takim przypadku
					trzeba zrobiÄ‡ gÅ‚Ä™bokie klonowanie (deep copy).
				- Nadmierne uÅ¼ycie moÅ¼e skomplikowaÄ‡ kod i zwiÄ™kszyÄ‡ liczbÄ™ kopii w pamiÄ™ci.

	# Wzorce Strukturalne #
	1. Adapter
		# Kategoria: Strukturalny
			# Problem, ktÃ³ry rozwiÄ…zuje
				- Czasami mamy dwie klasy, ktÃ³re muszÄ… wspÃ³Å‚pracowaÄ‡, ale majÄ… niekompatybilne interfejsy.
				- Chcemy uÅ¼yÄ‡ istniejÄ…cej klasy, bez zmiany jej kodu, w nowym kontekÅ›cie.

			# Typowe przykÅ‚ady:
				- ÅÄ…czenie starego API z nowym systemem.
				- Integracja z bibliotekami zewnÄ™trznymi, ktÃ³re majÄ… inne metody niÅ¼ oczekuje nasz kod.
				- Systemy, gdzie rÃ³Å¼ne ÅºrÃ³dÅ‚a danych (CSV, JSON, XML) muszÄ… mieÄ‡ jednolity interfejs.

			# Bez Adaptera:
				- Trzeba by zmieniaÄ‡ stary kod â†’ niepoÅ¼Ä…dane.
					OldSystem oldSystem = new OldSystem();
					oldSystem.oldRequest(); // klient oczekuje metody newRequest()

			# RozwiÄ…zanie
				- Tworzymy klasÄ™ Adapter, ktÃ³ra implementuje interfejs oczekiwany przez klienta i wywoÅ‚uje metody starego obiektu.
				- Adapter â€œtÅ‚umaczyâ€ interfejsy.

		# Implementacja w Javie
			# Krok 1: Interfejs docelowy
				interface Target {
				    void request(); // metoda oczekiwana przez klienta
				}

			# Krok 2: Klasa istniejÄ…ca (adaptee)
				class Adaptee {
				    public void specificRequest() {
				        System.out.println("Specyficzna metoda Adaptee");
				    }
				}

			# Krok 3: Adapter
				class Adapter implements Target {
				    private Adaptee adaptee;

				    public Adapter(Adaptee adaptee) {
				        this.adaptee = adaptee;
				    }

				    @Override
				    public void request() {
				        // Adapter tÅ‚umaczy wywoÅ‚anie
				        adaptee.specificRequest();
				    }
				}

			# UÅ¼ycie w praktyce
				public class Main {
				    public static void main(String[] args) {
				        Adaptee oldSystem = new Adaptee();
				        Target adapter = new Adapter(oldSystem);

				        // Klient uÅ¼ywa interfejsu Target
				        adapter.request();
				    }
				}

			# Zalety Adaptera
				- Pozwala uÅ¼ywaÄ‡ istniejÄ…cych klas w nowych kontekstach bez modyfikacji.
				- UÅ‚atwia integracjÄ™ zewnÄ™trznych bibliotek lub starszego kodu.
				- Oddziela klienta od szczegÃ³Å‚Ã³w implementacji klasy adaptee.

			# Wady / puÅ‚apki
				- Dodaje kolejnÄ… warstwÄ™ poÅ›redniÄ… â†’ drobny narzut w kodzie.
				- Nadmierne uÅ¼ycie moÅ¼e skomplikowaÄ‡ architekturÄ™.

	2. Decorator
		# Kategoria: Strukturalny
		# Problem, ktÃ³ry rozwiÄ…zuje
			# Chcemy dynamicznie dodawaÄ‡ nowe funkcjonalnoÅ›ci do obiektu, bez zmiany jego klasy.
			# Dziedziczenie czasami nie wystarcza:
				- Zbyt wiele kombinacji klas byÅ‚oby potrzebne,
				- Nie moÅ¼na przewidzieÄ‡ wszystkich rozszerzeÅ„ w czasie kompilacji.

			# Typowe przykÅ‚ady:
				- Systemy graficzne: dodawanie efektÃ³w do okienek (border, scroll, shadow).
				- Streamy w Javie: np. BufferedInputStream dekorujÄ…cy FileInputStream.
				- Systemy zamÃ³wieÅ„: dodawanie opcji do podstawowego produktu (np. gift wrap, ekspresowa wysyÅ‚ka).

			# RozwiÄ…zanie
				- Tworzymy interfejs lub klasÄ™ abstrakcyjnÄ… bazowego obiektu.
				- Dekoratory implementujÄ… ten sam interfejs i zawierajÄ… instancjÄ™ obiektu, ktÃ³ry dekorujÄ….
				- Metody dekoratora wywoÅ‚ujÄ… oryginalne metody obiektu i dodajÄ… dodatkowÄ… funkcjonalnoÅ›Ä‡.

			# Implementacja w Javie
				Krok 1: Interfejs komponentu
					interface Coffee {
					    double cost();
					    String description();
					}

				Krok 2: Konkretna klasa
					class SimpleCoffee implements Coffee {
					    public double cost() {
					        return 5.0;
					    }

					    public String description() {
					        return "Simple Coffee";
					    }
					}

				Krok 3: Abstrakcyjny dekorator
					abstract class CoffeeDecorator implements Coffee {
					    protected Coffee decoratedCoffee;

					    public CoffeeDecorator(Coffee coffee) {
					        this.decoratedCoffee = coffee;
					    }

					    public double cost() {
					        return decoratedCoffee.cost();
					    }

					    public String description() {
					        return decoratedCoffee.description();
					    }
					}

				Krok 4: Konkretne dekoratory
					class MilkDecorator extends CoffeeDecorator {
					    public MilkDecorator(Coffee coffee) {
					        super(coffee);
					    }

					    @Override
					    public double cost() {
					        return super.cost() + 2.0;
					    }

					    @Override
					    public String description() {
					        return super.description() + ", Milk";
					    }
					}

					class SugarDecorator extends CoffeeDecorator {
					    public SugarDecorator(Coffee coffee) {
					        super(coffee);
					    }

					    @Override
					    public double cost() {
					        return super.cost() + 1.0;
					    }

					    @Override
					    public String description() {
					        return super.description() + ", Sugar";
					    }
					}

				# UÅ¼ycie w praktyce
					public class Main {
					    public static void main(String[] args) {
					        Coffee coffee = new SimpleCoffee();
					        System.out.println(coffee.description() + " $" + coffee.cost());

					        Coffee milkCoffee = new MilkDecorator(coffee);
					        System.out.println(milkCoffee.description() + " $" + milkCoffee.cost());

					        Coffee milkSugarCoffee = new SugarDecorator(milkCoffee);
					        System.out.println(milkSugarCoffee.description() + " $" + milkSugarCoffee.cost());
					    }
					}

				# Zalety Decoratora
					- Dynamiczne dodawanie funkcjonalnoÅ›ci w runtime.
					- Unika tworzenia wielu klas pochodnych dla kombinacji funkcjonalnoÅ›ci.
					- Otwarty na rozszerzenia, zamkniÄ™ty na modyfikacje (zasada Open/Closed).

				# Wady / puÅ‚apki
					- MoÅ¼e prowadziÄ‡ do gÅ‚Ä™bokich, trudnych do Å›ledzenia dekoratorÃ³w (chain).
					- Trzeba uwaÅ¼aÄ‡ na kolejnoÅ›Ä‡ dekoratorÃ³w, bo zmienia wynik.

	3. Facade
		# Kategoria: Strukturalny

			# Problem, ktÃ³ry rozwiÄ…zuje
				# W duÅ¼ych systemach klient czÄ™sto musi korzystaÄ‡ z wielu klas i interfejsÃ³w, co jest skomplikowane.
				# BezpoÅ›rednia interakcja z wszystkimi klasami:
					- ZwiÄ™ksza zÅ‚oÅ¼onoÅ›Ä‡ kodu klienta,
					- Utrudnia utrzymanie systemu,
					- Powoduje powtarzalnoÅ›Ä‡ wywoÅ‚aÅ„.

			# Typowe przykÅ‚ady:
				- Systemy multimedialne: odtwarzacz, kodeki, dekodery, ekwalizer â†’ klient potrzebuje tylko prostego â€Playâ€.
				- Systemy pÅ‚atnoÅ›ci: klient wywoÅ‚uje prostÄ… metodÄ™ pay(), a fasada obsÅ‚uguje logikÄ™ autoryzacji, walidacji, ksiÄ™gowania.
				- Systemy domowe (smart home): wÅ‚Ä…cz Å›wiatÅ‚o, alarm, ogrzewanie jednym wywoÅ‚aniem.

			# RozwiÄ…zanie
				- Tworzymy jednÄ… klasÄ™ Facade, ktÃ³ra udostÄ™pnia prosty interfejs.
				- Facade ukrywa zÅ‚oÅ¼onoÅ›Ä‡ podsystemÃ³w, a klient uÅ¼ywa tylko tej klasy.
				- UÅ‚atwia integracjÄ™ i utrzymanie.

		# Implementacja w Javie
			# Krok 1: Podsystemy
				class CPU {
				    public void start() { System.out.println("CPU starting"); }
				}

				class Memory {
				    public void load() { System.out.println("Loading memory"); }
				}

				class HardDrive {
				    public void read() { System.out.println("Reading data from hard drive"); }
				}

			# Krok 2: Facade
				class ComputerFacade {
				    private CPU cpu;
				    private Memory memory;
				    private HardDrive hardDrive;

				    public ComputerFacade() {
				        this.cpu = new CPU();
				        this.memory = new Memory();
				        this.hardDrive = new HardDrive();
				    }

				    // Prosty interfejs dla klienta
				    public void startComputer() {
				        cpu.start();
				        memory.load();
				        hardDrive.read();
				        System.out.println("Computer started successfully!");
				    }
				}

			# UÅ¼ycie w praktyce
				 public class Main {
				    public static void main(String[] args) {
				        ComputerFacade computer = new ComputerFacade();

				        // Klient uÅ¼ywa tylko jednej metody
				        computer.startComputer();
				    }
				}

			# Zalety Facade
				1. Upraszcza interfejs dla klienta.
				2. Ukrywa zÅ‚oÅ¼onoÅ›Ä‡ podsystemÃ³w.
				3. Åatwo rozbudowywaÄ‡ podsystemy bez zmiany klienta.
				4. UÅ‚atwia utrzymanie i integracjÄ™.

			# Wady / puÅ‚apki
				1.Nie eliminuje zÅ‚oÅ¼onoÅ›ci wewnÄ™trznej systemu â€“ tylko jÄ… ukrywa.
				2.Nadmierne stosowanie moÅ¼e prowadziÄ‡ do â€œsuper-fasadyâ€, ktÃ³ra robi za duÅ¼o.


	4. Proxy
		# Kategoria: Strukturalny
		# Problem, ktÃ³ry rozwiÄ…zuje
			- Chcemy kontrolowaÄ‡ dostÄ™p do obiektu lub dodaÄ‡ dodatkowÄ… funkcjonalnoÅ›Ä‡, nie zmieniajÄ…c klasy oryginalnej.

			# Typowe sytuacje:
				- Lazy loading â€“ obiekt jest tworzony dopiero wtedy, gdy jest potrzebny.
				- Kontrola dostÄ™pu â€“ np. autoryzacja przed wywoÅ‚aniem metody.
				- Caching â€“ przechowywanie wynikÃ³w dla drogiego w obliczeniach obiektu.
				- Zdalne wywoÅ‚ania (Remote Proxy) â€“ np. klient lokalny odwoÅ‚uje siÄ™ do serwera.

		# Bez Proxy:
			- Za kaÅ¼dym razem tworzysz kosztowny obiekt, nawet jeÅ›li go nie potrzebujesz.
			# Kod
				ExpensiveService service = new ExpensiveService();
				service.process();
		# RozwiÄ…zanie
			- Tworzymy interfejs dla obiektu.
			- Tworzymy Proxy, ktÃ³ry implementuje ten sam interfejs i kontroluje dostÄ™p do prawdziwego obiektu (RealSubject).
			- Proxy moÅ¼e:
				- TworzyÄ‡ obiekt dopiero przy pierwszym wywoÅ‚aniu,
				- DodaÄ‡ logowanie, autoryzacjÄ™, cache, itd.

		# Implementacja w Javie
			Krok 1: Interfejs
				interface Image {
				    void display();
				}

			Krok 2: Realny obiekt
				class RealImage implements Image {
				    private String filename;

				    public RealImage(String filename) {
				        this.filename = filename;
				        loadFromDisk();
				    }

				    private void loadFromDisk() {
				        System.out.println("Loading " + filename);
				    }

				    @Override
				    public void display() {
				        System.out.println("Displaying " + filename);
				    }
				}

			Krok 3: Proxy
				class ProxyImage implements Image {
				    private RealImage realImage;
				    private String filename;

				    public ProxyImage(String filename) {
				        this.filename = filename;
				    }

				    @Override
				    public void display() {
				        if(realImage == null) {
				            // Tworzymy obiekt dopiero przy pierwszym wywoÅ‚aniu
				            realImage = new RealImage(filename);
				        }
				        realImage.display();
				    }
				}

			# UÅ¼ycie w praktyce
				public class Main {
				    public static void main(String[] args) {
				        Image image1 = new ProxyImage("photo1.jpg");
				        Image image2 = new ProxyImage("photo2.jpg");

				        // Obraz Å‚adowany dopiero przy pierwszym wyÅ›wietleniu
				        image1.display();
				        image1.display(); // nie Å‚aduje ponownie

				        image2.display();
				    }
				}

		# Zalety Proxy
			- Kontrola dostÄ™pu do obiektu.
			- MoÅ¼liwoÅ›Ä‡ lazy loading lub cache.
			- Oddzielenie klienta od kosztownych operacji.
			- MoÅ¼e dodawaÄ‡ funkcjonalnoÅ›Ä‡ (logowanie, bezpieczeÅ„stwo) bez zmiany oryginaÅ‚u.

		# Wady / puÅ‚apki
			- Dodatkowa warstwa poÅ›rednia â†’ drobny narzut w wydajnoÅ›ci.
			- MoÅ¼e skomplikowaÄ‡ debugowanie, jeÅ›li jest wiele proxy w Å‚aÅ„cuchu.

	5. Copasite
		# Kategoria: Strukturalny
		# Problem, ktÃ³ry rozwiÄ…zuje
			## Mamy strukturÄ™ drzewiastÄ… â€“ obiekty zÅ‚oÅ¼one z mniejszych obiektÃ³w.
			## Chcemy traktowaÄ‡ pojedyncze obiekty i grupy obiektÃ³w w taki sam sposÃ³b.
			## Typowe przykÅ‚ady:
				- System plikÃ³w (pliki i foldery).
				- Menu w aplikacji (pojedyncze elementy vs podmenu).

			- Organizacja firmy (pracownik vs dziaÅ‚ skÅ‚adajÄ…cy siÄ™ z pracownikÃ³w).

			# Bez Composite musielibyÅ›my pisaÄ‡ rÃ³Å¼ne metody dla â€liÅ›ciâ€ i â€gaÅ‚Ä™ziâ€, co komplikuje kod.
			# RozwiÄ…zanie
				- Definiujemy wspÃ³lny interfejs Component dla:
					- Leaf (liÅ›Ä‡) â€“ pojedynczy obiekt.
					- Composite (gaÅ‚Ä…Åº) â€“ obiekt zawierajÄ…cy inne Component.
				- DziÄ™ki temu klient nie musi rozrÃ³Å¼niaÄ‡, czy pracuje na liÅ›ciu czy gaÅ‚Ä™zi.

			# Implementacja w Javie
				Krok 1: WspÃ³lny interfejs
					interface Graphic {
					    void draw();
					}

				Krok 2: LiÅ›Ä‡
					class Circle implements Graphic {
					    @Override
					    public void draw() {
					        System.out.println("Drawing Circle");
					    }
					}

				Krok 3: Kompozyt (moÅ¼e zawieraÄ‡ inne obiekty)
					import java.util.ArrayList;
					import java.util.List;

					class GraphicGroup implements Graphic {
					    private List<Graphic> children = new ArrayList<>();

					    public void add(Graphic g) {
					        children.add(g);
					    }

					    public void remove(Graphic g) {
					        children.remove(g);
					    }

					    @Override
					    public void draw() {
					        for (Graphic g : children) {
					            g.draw();
					        }
					    }
					}

				# UÅ¼ycie w praktyce
					public class Main {
					    public static void main(String[] args) {
					        Circle c1 = new Circle();
					        Circle c2 = new Circle();

					        GraphicGroup group = new GraphicGroup();
					        group.add(c1);
					        group.add(c2);

					        // MoÅ¼emy traktowaÄ‡ caÅ‚Ä… grupÄ™ jak pojedynczy obiekt
					        group.draw();
					    }
					}

				# Zalety Composite
					- Upraszcza kod â€“ klient nie musi wiedzieÄ‡, czy ma do czynienia z liÅ›ciem czy grupÄ….
					- Åatwe budowanie hierarchicznych struktur (np. drzewo plikÃ³w).
					- Rekurencja pasuje naturalnie do pracy z kompozytem.

				# Wady / puÅ‚apki
					- Trudniej kontrolowaÄ‡ dostÄ™p, jeÅ›li klient powinien odrÃ³Å¼niaÄ‡ liÅ›Ä‡ od kompozytu.
					- Struktura moÅ¼e staÄ‡ siÄ™ bardzo ogÃ³lna i trudna do optymalizacji.

	6. Bridge
		Kategoria: Strukturalny
		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Bez wzorca Bridge czÄ™sto mamy problem z eksplozjÄ… klas.
			# ZaÅ‚Ã³Å¼my, Å¼e chcemy zaimplementowaÄ‡ rÃ³Å¼ne ksztaÅ‚ty (np. KoÅ‚o, Kwadrat) i kaÅ¼dy z nich moÅ¼e byÄ‡ rysowany
				w rÃ³Å¼ny sposÃ³b (np. czerwony, niebieski).

			# Bez Bridge musielibyÅ›my tworzyÄ‡ klasy typu:
				- CzerwoneKoÅ‚o,
				- NiebieskieKoÅ‚o,
				- CzerwonyKwadrat,
				- NiebieskiKwadrat, itd.

			# Co przy wiÄ™kszej liczbie wariantÃ³w prowadzi do duÅ¼ej liczby klas.
			# Wzorzec Bridge rozwiÄ…zuje to poprzez rozdzielenie hierarchii klas na:

			1. AbstrakcjÄ™ (np. Shape â€“ KsztaÅ‚t).
			2. ImplementacjÄ™ (np. Color â€“ Kolor).

		ğŸ”¹ Struktura
			Abstraction â€“ gÅ‚Ã³wna abstrakcja, ktÃ³ra deleguje pracÄ™ do implementacji.
			RefinedAbstraction â€“ rozszerzona wersja abstrakcji.
			Implementor â€“ interfejs implementacji.
			ConcreteImplementor â€“ konkretna implementacja.

		ğŸ”¹ PrzykÅ‚ad w Javie
			// Implementor
			interface Color {
			    String fill();
			}

			// ConcreteImplementors
			class RedColor implements Color {
			    @Override
			    public String fill() {
			        return "czerwony";
			    }
			}

			class BlueColor implements Color {
			    @Override
			    public String fill() {
			        return "niebieski";
			    }
			}

			// Abstraction
			abstract class Shape {
			    protected Color color;

			    public Shape(Color color) {
			        this.color = color;
			    }

			    abstract void draw();
			}

			// RefinedAbstractions
			class Circle extends Shape {
			    public Circle(Color color) {
			        super(color);
			    }

			    @Override
			    void draw() {
			        System.out.println("RysujÄ™ koÅ‚o w kolorze: " + color.fill());
			    }
			}

			class Square extends Shape {
			    public Square(Color color) {
			        super(color);
			    }

			    @Override
			    void draw() {
			        System.out.println("RysujÄ™ kwadrat w kolorze: " + color.fill());
			    }
			}

			// Klient
			public class BridgeExample {
			    public static void main(String[] args) {
			        Shape redCircle = new Circle(new RedColor());
			        Shape blueSquare = new Square(new BlueColor());

			        redCircle.draw();   // RysujÄ™ koÅ‚o w kolorze: czerwony
			        blueSquare.draw();  // RysujÄ™ kwadrat w kolorze: niebieski
			    }
			}

		ğŸ”¹ Zalety Bridge
			Unika eksplozji klas (nie trzeba robiÄ‡ kaÅ¼dej kombinacji osobno).
			Åatwe rozszerzanie â€“ moÅ¼emy dodawaÄ‡ nowe ksztaÅ‚ty i kolory niezaleÅ¼nie.
			ZwiÄ™ksza elastycznoÅ›Ä‡ projektu.

	7. flyweight
		ğŸ”¹ Flyweight â€“ opis
			# Flyweight (z ang. pyÅ‚ek, â€lekkie obiektyâ€) to wzorzec projektowy, ktÃ³ry pozwala oszczÄ™dzaÄ‡ pamiÄ™Ä‡,
				dzielÄ…c wspÃ³lne dane pomiÄ™dzy wiele obiektÃ³w.
			# Zamiast tworzyÄ‡ tysiÄ…ce identycznych obiektÃ³w (ktÃ³re marnujÄ… pamiÄ™Ä‡), przechowujemy je w puli wspÃ³Å‚dzielonych
				 instancji i ponownie je wykorzystujemy.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
				# WyobraÅº sobie grÄ™, gdzie wyÅ›wietlanych jest np. milion drzew.
				# KaÅ¼de drzewo ma:
					- kolor liÅ›ci,
					- teksturÄ™ kory,
					- ksztaÅ‚t korony,
					- wspÃ³Å‚rzÄ™dne X i Y.

			ğŸ‘‰ Bez Flyweight: dla miliona drzew przechowujesz te same dane tekstury i koloru milion razy â†’ ogromne zuÅ¼ycie pamiÄ™ci.
			ğŸ‘‰ Z Flyweight: dane wspÃ³lne (tekstury, kolory) sÄ… wspÃ³Å‚dzielone w jednym obiekcie, a zmienne dane (np. wspÃ³Å‚rzÄ™dne) trzymane osobno.

		ğŸ”¹ Struktura
			Flyweight â€“ interfejs dla wspÃ³Å‚dzielonych obiektÃ³w.
			ConcreteFlyweight â€“ implementacja obiektu wspÃ³Å‚dzielonego.
			FlyweightFactory â€“ zarzÄ…dza tworzeniem i przechowywaniem obiektÃ³w Flyweight, Å¼eby je wspÃ³Å‚dzieliÄ‡.
			Client â€“ uÅ¼ywa Flyweight, ale dodaje do niego dane unikalne (tzw. stan zewnÄ™trzny).

		ğŸ”¹ PrzykÅ‚ad w Javie
			# PrzykÅ‚ad: litery w edytorze tekstu â€“ kaÅ¼da litera ma ten sam ksztaÅ‚t (stan wspÃ³Å‚dzielony), ale rÃ³Å¼ne pozycje na ekranie (stan zewnÄ™trzny).
			# Kod
				import java.util.HashMap;
				import java.util.Map;

				// Flyweight
				interface Glyph {
				    void draw(int x, int y); // x,y to stan zewnÄ™trzny (unikalny)
				}

				// ConcreteFlyweight
				class CharacterGlyph implements Glyph {
				    private final char symbol; // stan wspÃ³Å‚dzielony

				    public CharacterGlyph(char symbol) {
				        this.symbol = symbol;
				    }

				    @Override
				    public void draw(int x, int y) {
				        System.out.println("RysujÄ™ '" + symbol + "' na pozycji (" + x + "," + y + ")");
				    }
				}

				// FlyweightFactory
				class GlyphFactory {
				    private final Map<Character, Glyph> pool = new HashMap<>();

				    public Glyph getGlyph(char symbol) {
				        pool.putIfAbsent(symbol, new CharacterGlyph(symbol));
				        return pool.get(symbol);
				    }
				}

				// Client
				public class FlyweightExample {
				    public static void main(String[] args) {
				        GlyphFactory factory = new GlyphFactory();

				        String text = "HELLO";
				        int x = 0;

				        for (char c : text.toCharArray()) {
				            Glyph glyph = factory.getGlyph(c);
				            glyph.draw(x, 10); // stan zewnÄ™trzny = pozycja
				            x += 10;
				        }
				    }
				}

		ğŸ”¹ Wynik
			RysujÄ™ 'H' na pozycji (0,10)
			RysujÄ™ 'E' na pozycji (10,10)
			RysujÄ™ 'L' na pozycji (20,10)
			RysujÄ™ 'L' na pozycji (30,10)
			RysujÄ™ 'O' na pozycji (40,10)

			â¡ï¸ Litera L zostaÅ‚a pobrana z tej samej instancji, a nie tworzona dwa razy â€“ oszczÄ™dzamy pamiÄ™Ä‡.

		ğŸ”¹ Zalety Flyweight
			- DuÅ¼a oszczÄ™dnoÅ›Ä‡ pamiÄ™ci przy pracy z ogromnÄ… iloÅ›ciÄ… podobnych obiektÃ³w.
			- Separacja stanu wewnÄ™trznego (wspÃ³lnego) i zewnÄ™trznego (unikalnego).

	# Wzorce Behawioralne #
	1. Observer
		ğŸ”¹ Observer â€“ opis
			Observer (pol. Obserwator) to wzorzec projektowy z kategorii behawioralnych, ktÃ³ry umoÅ¼liwia reakcjÄ™ wielu
				obiektÃ³w na zmianÄ™ stanu jednego obiektu.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Bez Observera, jeÅ›li mamy np. obiekt â€gazetaâ€ i wielu czytelnikÃ³w, to trzeba by rÄ™cznie powiadamiaÄ‡
				 kaÅ¼dego czytelnika o nowym wydaniu.
			# To prowadzi do silnego powiÄ…zania i trudnej rozbudowy.

			ğŸ‘‰ DziÄ™ki Observer:
				# Obiekt Subject (wydawca) wie tylko, Å¼e ma listÄ™ ObserverÃ³w (subskrybentÃ³w).
				# Gdy jego stan siÄ™ zmienia â†’ automatycznie powiadamia wszystkich obserwatorÃ³w.
				# To dokÅ‚adnie mechanizm publish/subscribe (Pub/Sub).

		ğŸ”¹ Struktura
			Subject â€“ obiekt obserwowany (wydawca).
			Observer â€“ interfejs dla obserwatorÃ³w (subskrybentÃ³w).
			ConcreteSubject â€“ implementacja obserwowanego obiektu.
			ConcreteObserver â€“ konkretni obserwatorzy, reagujÄ…cy na zmiany.

		ğŸ”¹ PrzykÅ‚ad w Javie
			Scenariusz: serwis newsowy â€“ czytelnicy subskrybujÄ… wiadomoÅ›ci.
			# Kod
				import java.util.ArrayList;
				import java.util.List;

				// Observer
				interface Observer {
				    void update(String news);
				}

				// ConcreteObserver
				class Reader implements Observer {
				    private String name;

				    public Reader(String name) {
				        this.name = name;
				    }

				    @Override
				    public void update(String news) {
				        System.out.println(name + " otrzymaÅ‚ wiadomoÅ›Ä‡: " + news);
				    }
				}

				// Subject
				interface Subject {
				    void subscribe(Observer observer);
				    void unsubscribe(Observer observer);
				    void notifyObservers(String news);
				}

				// ConcreteSubject
				class NewsPublisher implements Subject {
				    private List<Observer> observers = new ArrayList<>();

				    @Override
				    public void subscribe(Observer observer) {
				        observers.add(observer);
				    }

				    @Override
				    public void unsubscribe(Observer observer) {
				        observers.remove(observer);
				    }

				    @Override
				    public void notifyObservers(String news) {
				        for (Observer observer : observers) {
				            observer.update(news);
				        }
				    }

				    // metoda publikacji wiadomoÅ›ci
				    public void publishNews(String news) {
				        System.out.println("\nğŸ“° Publikacja: " + news);
				        notifyObservers(news);
				    }
				}

				// Klient
				public class ObserverExample {
				    public static void main(String[] args) {
				        NewsPublisher publisher = new NewsPublisher();

				        Observer reader1 = new Reader("Jan");
				        Observer reader2 = new Reader("Anna");
				        Observer reader3 = new Reader("Kasia");

				        publisher.subscribe(reader1);
				        publisher.subscribe(reader2);
				        publisher.subscribe(reader3);

				        publisher.publishNews("Nowy artykuÅ‚ o Javie!");
				        publisher.publishNews("Wzorce projektowe w praktyce.");

				        // Kasia wypisuje siÄ™ z subskrypcji
				        publisher.unsubscribe(reader3);

				        publisher.publishNews("Ostatnie wiadomoÅ›ci na dziÅ›.");
				    }
				}

			ğŸ”¹ Wynik dziaÅ‚ania
				ğŸ“° Publikacja: Nowy artykuÅ‚ o Javie!
				Jan otrzymaÅ‚ wiadomoÅ›Ä‡: Nowy artykuÅ‚ o Javie!
				Anna otrzymaÅ‚ wiadomoÅ›Ä‡: Nowy artykuÅ‚ o Javie!
				Kasia otrzymaÅ‚ wiadomoÅ›Ä‡: Nowy artykuÅ‚ o Javie!

				ğŸ“° Publikacja: Wzorce projektowe w praktyce.
				Jan otrzymaÅ‚ wiadomoÅ›Ä‡: Wzorce projektowe w praktyce.
				Anna otrzymaÅ‚ wiadomoÅ›Ä‡: Wzorce projektowe w praktyce.
				Kasia otrzymaÅ‚ wiadomoÅ›Ä‡: Wzorce projektowe w praktyce.

				ğŸ“° Publikacja: Ostatnie wiadomoÅ›ci na dziÅ›.
				Jan otrzymaÅ‚ wiadomoÅ›Ä‡: Ostatnie wiadomoÅ›ci na dziÅ›.
				Anna otrzymaÅ‚ wiadomoÅ›Ä‡: Ostatnie wiadomoÅ›ci na dziÅ›.

			ğŸ”¹ Zalety Observer
				- LuÅºne powiÄ…zanie miÄ™dzy wydawcÄ… a subskrybentami.
				- Åatwo dodawaÄ‡ nowych obserwatorÃ³w bez modyfikowania kodu wydawcy.
				- Naturalnie wspiera wzorzec event-driven.


	2. Strategy
		ğŸ”¹ Strategy â€“ opis
			# trategy (pol. Strategia) to wzorzec behawioralny, ktÃ³ry pozwala definiowaÄ‡ rodzinÄ™ algorytmÃ³w, zamykaÄ‡
				je w oddzielnych klasach i wymieniaÄ‡ w trakcie dziaÅ‚ania programu.
			# Zamiast pisaÄ‡ kod typu:
				â€“ delegujemy wybÃ³r algorytmu do osobnych klas i klient moÅ¼e Å‚atwo zmieniaÄ‡ strategiÄ™.
				# Kod
					if (algorytm == 1) { ... } else if (algorytm == 2) { ... }

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			Unika duÅ¼ych blokÃ³w if-else / switch-case.
			UmoÅ¼liwia dynamiczne zmienianie sposobu dziaÅ‚ania programu.
			UÅ‚atwia dodawanie nowych algorytmÃ³w bez ruszania kodu klienta.

		ğŸ”¹ Struktura
			Strategy â€“ interfejs strategii (definiuje metodÄ™).
			ConcreteStrategy â€“ konkretna implementacja algorytmu.
			Context â€“ klasa uÅ¼ywajÄ…ca strategii, deleguje pracÄ™ do wybranej strategii.

		ğŸ”¹ PrzykÅ‚ad w Javie
			Scenariusz: obliczanie ceny biletu z rÃ³Å¼nymi zniÅ¼kami (student, senior, brak zniÅ¼ki).
			# Kod
				interface DiscountStrategy {
				    double applyDiscount(double price);
				}

				// ConcreteStrategies
				class NoDiscount implements DiscountStrategy {
				    @Override
				    public double applyDiscount(double price) {
				        return price;
				    }
				}

				class StudentDiscount implements DiscountStrategy {
				    @Override
				    public double applyDiscount(double price) {
				        return price * 0.5; // 50% zniÅ¼ki
				    }
				}

				class SeniorDiscount implements DiscountStrategy {
				    @Override
				    public double applyDiscount(double price) {
				        return price * 0.7; // 30% zniÅ¼ki
				    }
				}

				// Context
				class Ticket {
				    private DiscountStrategy discountStrategy;

				    public Ticket(DiscountStrategy discountStrategy) {
				        this.discountStrategy = discountStrategy;
				    }

				    public void setDiscountStrategy(DiscountStrategy discountStrategy) {
				        this.discountStrategy = discountStrategy;
				    }

				    public double getFinalPrice(double basePrice) {
				        return discountStrategy.applyDiscount(basePrice);
				    }
				}

				// Klient
				public class StrategyExample {
				    public static void main(String[] args) {
				        double basePrice = 100.0;

				        Ticket ticket = new Ticket(new NoDiscount());
				        System.out.println("Cena normalna: " + ticket.getFinalPrice(basePrice));

				        ticket.setDiscountStrategy(new StudentDiscount());
				        System.out.println("Cena dla studenta: " + ticket.getFinalPrice(basePrice));

				        ticket.setDiscountStrategy(new SeniorDiscount());
				        System.out.println("Cena dla seniora: " + ticket.getFinalPrice(basePrice));
				    }
				}

		ğŸ”¹ Wynik dziaÅ‚ania
			Cena normalna: 100.0
			Cena dla studenta: 50.0
			Cena dla seniora: 70.0

		ğŸ”¹ Zalety Strategy
			- Åatwe rozszerzanie (dodajesz nowÄ… strategiÄ™ bez modyfikacji kodu kontekstu).
			- Wymiana algorytmu w trakcie dziaÅ‚ania programu.
			- Eliminuje rozbudowane instrukcje warunkowe.

	3. Command
		ğŸ”¹ Command â€“ opis
			# Command (pol. Polecenie) to wzorzec behawioralny, ktÃ³ry zamienia Å¼Ä…danie w obiekt.
				DziÄ™ki temu:
				moÅ¼emy przekazywaÄ‡ polecenia jak dane,
				kolejkowaÄ‡ je,
				cofaÄ‡/ponawiaÄ‡ (undo/redo),
				oddzieliÄ‡ obiekt, ktÃ³ry wydaje polecenie, od obiektu, ktÃ³ry je wykonuje.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?

			WyobraÅº sobie pilota do telewizora:

			przyciski pilota wydajÄ… polecenia (wÅ‚Ä…cz, wyÅ‚Ä…cz, zmieÅ„ kanaÅ‚).

			pilot nie musi wiedzieÄ‡, jak dokÅ‚adnie telewizor dziaÅ‚a â€“ po prostu wysyÅ‚a komendy.

			ğŸ‘‰ DziÄ™ki wzorcowi Command mamy luÅºne powiÄ…zanie miÄ™dzy nadawcÄ… (Invoker â€“ np. pilot) a odbiorcÄ… (Receiver â€“ np. telewizor).

		ğŸ”¹ Struktura
			Command â€“ interfejs polecenia, definiuje metodÄ™ execute().
			ConcreteCommand â€“ konkretne polecenie (np. WÅ‚Ä…czTV).
			Receiver â€“ obiekt, ktÃ³ry wykonuje wÅ‚aÅ›ciwe dziaÅ‚anie (np. telewizor).
			Invoker â€“ obiekt, ktÃ³ry wywoÅ‚uje polecenie (np. pilot).
			Client â€“ konfiguruje polecenia, przypisuje je do invokera.

		ğŸ”¹ PrzykÅ‚ad w Javie
			Scenariusz: pilot sterujÄ…cy Å›wiatÅ‚em w pokoju.
			# Kod
				// Command
				interface Command {
				    void execute();
				}

				// Receiver
				class Light {
				    public void turnOn() {
				        System.out.println("ğŸ’¡ ÅšwiatÅ‚o wÅ‚Ä…czone");
				    }

				    public void turnOff() {
				        System.out.println("ğŸ’¡ ÅšwiatÅ‚o wyÅ‚Ä…czone");
				    }
				}

				// ConcreteCommands
				class TurnOnLightCommand implements Command {
				    private Light light;

				    public TurnOnLightCommand(Light light) {
				        this.light = light;
				    }

				    @Override
				    public void execute() {
				        light.turnOn();
				    }
				}

				class TurnOffLightCommand implements Command {
				    private Light light;

				    public TurnOffLightCommand(Light light) {
				        this.light = light;
				    }

				    @Override
				    public void execute() {
				        light.turnOff();
				    }
				}

				// Invoker
				class RemoteControl {
				    private Command command;

				    public void setCommand(Command command) {
				        this.command = command;
				    }

				    public void pressButton() {
				        command.execute();
				    }
				}

				// Client
				public class CommandExample {
				    public static void main(String[] args) {
				        Light light = new Light();

				        Command turnOn = new TurnOnLightCommand(light);
				        Command turnOff = new TurnOffLightCommand(light);

				        RemoteControl remote = new RemoteControl();

				        remote.setCommand(turnOn);
				        remote.pressButton();  // ğŸ’¡ ÅšwiatÅ‚o wÅ‚Ä…czone

				        remote.setCommand(turnOff);
				        remote.pressButton();  // ğŸ’¡ ÅšwiatÅ‚o wyÅ‚Ä…czone
				    }
				}

				}

		ğŸ”¹ Zalety Command
		    Oddzielenie obiektu Å¼Ä…dajÄ…cego (Invoker) od wykonawcy (Receiver).
		    Åatwo dodawaÄ‡ nowe polecenia bez zmiany istniejÄ…cego kodu.
		    ObsÅ‚uguje kolejkowanie i historiÄ™ poleceÅ„ (np. undo/redo).
		    Elastyczne przypisywanie akcji do przyciskÃ³w/menu.

	4. Chain of Responsibility
		ğŸ”¹ Chain of Responsibility â€“ opis
			# Chain of Responsibility (pol. ÅaÅ„cuch zobowiÄ…zaÅ„) to wzorzec behawioralny, ktÃ³ry pozwala przekazywaÄ‡ Å¼Ä…danie wzdÅ‚uÅ¼ Å‚aÅ„cucha obiektÃ³w, aÅ¼ ktÃ³ryÅ› je obsÅ‚uÅ¼y.
			# KaÅ¼dy obiekt w Å‚aÅ„cuchu:
				- moÅ¼e obsÅ‚uÅ¼yÄ‡ Å¼Ä…danie,
				- albo przekazuje je dalej do nastÄ™pnego elementu.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			- Eliminuje duÅ¼e bloki if-else sprawdzajÄ…ce â€kto powinien obsÅ‚uÅ¼yÄ‡ Å¼Ä…danieâ€.
			- Pozwala dodawaÄ‡ nowych obsÅ‚ugujÄ…cych bez zmiany istniejÄ…cego kodu.
			- UmoÅ¼liwia dynamiczne konfigurowanie kolejnoÅ›ci obsÅ‚ugi.
			- PrzykÅ‚ad Å¼ycia codziennego:
			- Masz pytanie w firmie â†’ najpierw pytasz kolegÄ™, jeÅ›li nie zna â†’ kierownik â†’ dyrektor â†’ prezes.
			- KaÅ¼dy w â€Å‚aÅ„cuchuâ€ decyduje, czy obsÅ‚uÅ¼yÄ‡ sprawÄ™, czy przekazaÄ‡ wyÅ¼ej.

		ğŸ”¹ Struktura
			- Handler â€“ interfejs/abstrakcyjna klasa dla elementÃ³w Å‚aÅ„cucha (ma referencjÄ™ do nastÄ™pnego).
			- ConcreteHandler â€“ konkretne implementacje obsÅ‚ugujÄ…ce lub przekazujÄ…ce dalej.
			- Client â€“ wysyÅ‚a Å¼Ä…danie do pierwszego elementu Å‚aÅ„cucha.

		ğŸ”¹ PrzykÅ‚ad w Javie
			# Scenariusz: system zatwierdzania wydatkÃ³w (pracownik, kierownik, dyrektor).
				// Handler
				abstract class Approver {
				    protected Approver next;

				    public void setNext(Approver next) {
				        this.next = next;
				    }

				    public abstract void approve(int amount);
				}

				// ConcreteHandlers
				class Employee extends Approver {
				    @Override
				    public void approve(int amount) {
				        if (amount <= 100) {
				            System.out.println("Pracownik zatwierdziÅ‚ wydatek: " + amount + " zÅ‚");
				        } else if (next != null) {
				            next.approve(amount);
				        }
				    }
				}

				class Manager extends Approver {
				    @Override
				    public void approve(int amount) {
				        if (amount <= 1000) {
				            System.out.println("Kierownik zatwierdziÅ‚ wydatek: " + amount + " zÅ‚");
				        } else if (next != null) {
				            next.approve(amount);
				        }
				    }
				}

				class Director extends Approver {
				    @Override
				    public void approve(int amount) {
				        if (amount <= 10000) {
				            System.out.println("Dyrektor zatwierdziÅ‚ wydatek: " + amount + " zÅ‚");
				        } else {
				            System.out.println("Wydatek " + amount + " zÅ‚ wymaga specjalnego zatwierdzenia!");
				        }
				    }
				}

				// Client
				public class ChainOfResponsibilityExample {
				    public static void main(String[] args) {
				        // Tworzymy Å‚aÅ„cuch
				        Approver employee = new Employee();
				        Approver manager = new Manager();
				        Approver director = new Director();

				        employee.setNext(manager);
				        manager.setNext(director);

				        // Testujemy rÃ³Å¼ne wydatki
				        employee.approve(50);     // obsÅ‚uÅ¼y pracownik
				        employee.approve(500);    // obsÅ‚uÅ¼y kierownik
				        employee.approve(5000);   // obsÅ‚uÅ¼y dyrektor
				        employee.approve(20000);  // brak obsÅ‚ugi w Å‚aÅ„cuchu
				    }
				}

		ğŸ”¹ Wynik dziaÅ‚ania
			Pracownik zatwierdziÅ‚ wydatek: 50 zÅ‚
			Kierownik zatwierdziÅ‚ wydatek: 500 zÅ‚
			Dyrektor zatwierdziÅ‚ wydatek: 5000 zÅ‚
			Wydatek 20000 zÅ‚ wymaga specjalnego zatwierdzenia!

		ğŸ”¹ Zalety Chain of Responsibility
			- LuÅºne powiÄ…zanie â€“ obiekty nie muszÄ… znaÄ‡ caÅ‚ej logiki, tylko swojego nastÄ™pcy.
			- Elastyczne rozszerzanie â€“ Å‚atwo dodawaÄ‡ nowe â€ogniwaâ€ Å‚aÅ„cucha.
			- ReuÅ¼ywalnoÅ›Ä‡ kodu â€“ poszczegÃ³lne obsÅ‚ugujÄ…ce mogÄ… dziaÅ‚aÄ‡ w rÃ³Å¼nych Å‚aÅ„cuchach.

	5. State
		ğŸ”¹ State â€“ opis
			# State (pol. Stan) to wzorzec behawioralny, ktÃ³ry pozwala obiektowi zmieniaÄ‡ swoje zachowanie w zaleÅ¼noÅ›ci od stanu, w ktÃ³rym siÄ™ znajduje.
			# W praktyce oznacza to, Å¼e zamiast ogromnego if-else/switch w klasie, logikÄ™ przenosimy do osobnych klas reprezentujÄ…cych konkretne stany.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Bez wzorca State:
				â¡ Kod szybko staje siÄ™ trudny do utrzymania.
				# Kod
					if (state == "draft") { ... }
					else if (state == "published") { ... }
					else if (state == "archived") { ... }

			# Z State:
				- KaÅ¼dy stan ma wÅ‚asnÄ… klasÄ™.
				- Obiekt kontekstu deleguje zachowanie do aktualnego stanu.
				- MoÅ¼emy Å‚atwo dodawaÄ‡ nowe stany, bez modyfikowania istniejÄ…cych.

		ğŸ”¹ Struktura
			State â€“ interfejs dla stanÃ³w.
			ConcreteState â€“ konkretne implementacje stanu (np. PlayingState, PausedState).
			Context â€“ obiekt przechowujÄ…cy aktualny stan, deleguje do niego zachowanie.

		ğŸ”¹ PrzykÅ‚ad w Javie
			# Scenariusz: odtwarzacz muzyki (stany: Odtwarzanie, Pauza, Stop).
			# Kod
				// State
				interface PlayerState {
				    void play(Player player);
				    void pause(Player player);
				    void stop(Player player);
				}

				// ConcreteStates
				class PlayingState implements PlayerState {
				    @Override
				    public void play(Player player) {
				        System.out.println("ğŸµ JuÅ¼ odtwarzam muzykÄ™!");
				    }

				    @Override
				    public void pause(Player player) {
				        System.out.println("â¸ Pauza");
				        player.setState(new PausedState());
				    }

				    @Override
				    public void stop(Player player) {
				        System.out.println("â¹ Stop");
				        player.setState(new StoppedState());
				    }
				}

				class PausedState implements PlayerState {
				    @Override
				    public void play(Player player) {
				        System.out.println("â–¶ Wznawiam odtwarzanie");
				        player.setState(new PlayingState());
				    }

				    @Override
				    public void pause(Player player) {
				        System.out.println("â¸ JuÅ¼ jest pauza!");
				    }

				    @Override
				    public void stop(Player player) {
				        System.out.println("â¹ ZatrzymujÄ™");
				        player.setState(new StoppedState());
				    }
				}

				class StoppedState implements PlayerState {
				    @Override
				    public void play(Player player) {
				        System.out.println("â–¶ Start odtwarzania");
				        player.setState(new PlayingState());
				    }

				    @Override
				    public void pause(Player player) {
				        System.out.println("â¸ Nie moÅ¼na pauzowaÄ‡ â€“ nic nie gra!");
				    }

				    @Override
				    public void stop(Player player) {
				        System.out.println("â¹ JuÅ¼ jest zatrzymany!");
				    }
				}

				// Context
				class Player {
				    private PlayerState state;

				    public Player() {
				        this.state = new StoppedState(); // stan poczÄ…tkowy
				    }

				    public void setState(PlayerState state) {
				        this.state = state;
				    }

				    public void play() {
				        state.play(this);
				    }

				    public void pause() {
				        state.pause(this);
				    }

				    public void stop() {
				        state.stop(this);
				    }
				}

				// Client
				public class StateExample {
				    public static void main(String[] args) {
				        Player player = new Player();

				        player.play();   // â–¶ Start odtwarzania
				        player.pause();  // â¸ Pauza
				        player.play();   // â–¶ Wznawiam odtwarzanie
				        player.stop();   // â¹ Stop
				        player.pause();  // â¸ Nie moÅ¼na pauzowaÄ‡ â€“ nic nie gra!
				    }
				}

		ğŸ”¹ Wynik dziaÅ‚ania
			â–¶ Start odtwarzania
			â¸ Pauza
			â–¶ Wznawiam odtwarzanie
			â¹ Stop
			â¸ Nie moÅ¼na pauzowaÄ‡ â€“ nic nie gra!

		ğŸ”¹ Zalety State
			- Eliminacja dÅ‚ugich instrukcji warunkowych.
			- Åatwe dodawanie nowych stanÃ³w.
			- Kod staje siÄ™ bardziej czytelny i zgodny z zasadÄ… Open/Closed.
			- KaÅ¼dy stan jest zamkniÄ™ty w swojej klasie â†’ wiÄ™ksza spÃ³jnoÅ›Ä‡.

	6. Template Method
		ğŸ”¹ Template Method â€“ opis
			- Template Method (pol. Metoda Szablonowa) to wzorzec behawioralny, ktÃ³ry pozwala zdefiniowaÄ‡ szkielet algorytmu
				w metodzie bazowej, a szczegÃ³Å‚y jego krokÃ³w pozostawiÄ‡ do implementacji w klasach pochodnych.

		ğŸ‘‰ Innymi sÅ‚owy:
			- Klasa bazowa zawiera algorytm ogÃ³lny (kolejnoÅ›Ä‡ krokÃ³w).
			- Podklasy mogÄ… nadpisywaÄ‡ poszczegÃ³lne kroki bez zmieniania struktury caÅ‚ego algorytmu.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			- Kiedy rÃ³Å¼ne klasy majÄ… podobny algorytm z drobnymi rÃ³Å¼nicami.
			- Zamiast duplikowaÄ‡ kod â†’ wyciÄ…gamy wspÃ³lnÄ… czÄ™Å›Ä‡ do klasy bazowej.
			- Zasada Hollywood Principle: â€Donâ€™t call us, weâ€™ll call youâ€ â€“ klasa bazowa decyduje, kiedy wywoÅ‚a metody podklas.

		ğŸ”¹ Struktura
			- AbstractClass â€“ definiuje szkielet algorytmu (metoda szablonowa) i abstrakcyjne â€krokiâ€.
			- ConcreteClass â€“ implementuje szczegÃ³Å‚y krokÃ³w.

		ğŸ”¹ PrzykÅ‚ad w Javie
			- Scenariusz: proces parzenia napojÃ³w (herbata i kawa).
			# Kod
				// AbstractClass
				abstract class Beverage {
				    // Template Method (szkielet algorytmu)
				    public final void prepareRecipe() {
				        boilWater();
				        brew();
				        pourInCup();
				        addCondiments();
				    }

				    private void boilWater() {
				        System.out.println("GotujÄ™ wodÄ™");
				    }

				    private void pourInCup() {
				        System.out.println("Wlewam do kubka");
				    }

				    // Kroki abstrakcyjne (do implementacji w podklasach)
				    protected abstract void brew();
				    protected abstract void addCondiments();
				}

				// ConcreteClass 1
				class Tea extends Beverage {
				    @Override
				    protected void brew() {
				        System.out.println("Zaparzam herbatÄ™");
				    }

				    @Override
				    protected void addCondiments() {
				        System.out.println("DodajÄ™ cytrynÄ™");
				    }
				}

				// ConcreteClass 2
				class Coffee extends Beverage {
				    @Override
				    protected void brew() {
				        System.out.println("Zaparzam kawÄ™");
				    }

				    @Override
				    protected void addCondiments() {
				        System.out.println("DodajÄ™ cukier i mleko");
				    }
				}

				// Client
				public class TemplateMethodExample {
				    public static void main(String[] args) {
				        System.out.println("â˜• PrzygotowujÄ™ kawÄ™:");
				        Beverage coffee = new Coffee();
				        coffee.prepareRecipe();

				        System.out.println("\nğŸµ PrzygotowujÄ™ herbatÄ™:");
				        Beverage tea = new Tea();
				        tea.prepareRecipe();
				    }
				}

		ğŸ”¹ Wynik dziaÅ‚ania
			â˜• PrzygotowujÄ™ kawÄ™:
			GotujÄ™ wodÄ™
			Zaparzam kawÄ™
			Wlewam do kubka
			DodajÄ™ cukier i mleko

			ğŸµ PrzygotowujÄ™ herbatÄ™:
			GotujÄ™ wodÄ™
			Zaparzam herbatÄ™
			Wlewam do kubka
			DodajÄ™ cytrynÄ™

		ğŸ”¹ Zalety Template Method
			- ReuÅ¼ywalnoÅ›Ä‡ kodu â€“ wspÃ³lne kroki sÄ… w klasie bazowej.
			- Åatwo rozszerzaÄ‡ â€“ nowe warianty algorytmu w podklasach.
			- Zachowana spÃ³jna struktura algorytmu.


	7. Mediator
		ğŸ”¹ Mediator â€“ opis
			- Mediator (pol. Mediator) to wzorzec behawioralny, ktÃ³ry centralizuje komunikacjÄ™ pomiÄ™dzy obiektami, tak aby nie musiaÅ‚y
				one odwoÅ‚ywaÄ‡ siÄ™ bezpoÅ›rednio do siebie.
			ğŸ‘‰ Zamiast tego kaÅ¼dy obiekt (tzw. Colleague) komunikuje siÄ™ przez Mediatora.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Bez Mediatora:
				- wiele obiektÃ³w komunikuje siÄ™ bezpoÅ›rednio, co prowadzi do gÄ™stej sieci zaleÅ¼noÅ›ci (â€spaghetti komunikacyjneâ€).
				- trudniej zmieniaÄ‡ logikÄ™ interakcji, bo trzeba modyfikowaÄ‡ wszystkie klasy.

			# Z Mediatorem:
				- obiekty znajÄ… tylko Mediatora, nie siebie nawzajem.
				- logika komunikacji jest scentralizowana i Å‚atwiejsza w utrzymaniu.

			# PrzykÅ‚ad Å¼ycia:
				- WieÅ¼a kontrolna na lotnisku â€“ samoloty nie rozmawiajÄ… ze sobÄ… bezpoÅ›rednio, tylko przez wieÅ¼Ä™ (mediatora).

		ğŸ”¹ Struktura
			- Mediator â€“ interfejs poÅ›rednika.
			- ConcreteMediator â€“ implementacja mediatora, zarzÄ…dza komunikacjÄ….
			- Colleague â€“ interfejs/abstrakcja uczestnikÃ³w.
			- ConcreteColleague â€“ klasy uczestnikÃ³w, ktÃ³re komunikujÄ… siÄ™ przez Mediatora.

		ğŸ”¹ PrzykÅ‚ad w Javie
			# Scenariusz: czat miÄ™dzy uÅ¼ytkownikami.
			# Kod
				import java.util.ArrayList;
				import java.util.List;

				// Mediator
				interface ChatMediator {
				    void sendMessage(String message, User sender);
				    void addUser(User user);
				}

				// ConcreteMediator
				class ChatRoom implements ChatMediator {
				    private List<User> users = new ArrayList<>();

				    @Override
				    public void addUser(User user) {
				        users.add(user);
				    }

				    @Override
				    public void sendMessage(String message, User sender) {
				        for (User user : users) {
				            if (user != sender) { // nie wysyÅ‚amy wiadomoÅ›ci do samego siebie
				                user.receive(message, sender);
				            }
				        }
				    }
				}

				// Colleague
				abstract class User {
				    protected ChatMediator mediator;
				    protected String name;

				    public User(ChatMediator mediator, String name) {
				        this.mediator = mediator;
				        this.name = name;
				    }

				    public abstract void send(String message);
				    public abstract void receive(String message, User sender);
				}

				// ConcreteColleague
				class ChatUser extends User {
				    public ChatUser(ChatMediator mediator, String name) {
				        super(mediator, name);
				    }

				    @Override
				    public void send(String message) {
				        System.out.println(name + " wysyÅ‚a: " + message);
				        mediator.sendMessage(message, this);
				    }

				    @Override
				    public void receive(String message, User sender) {
				        System.out.println(name + " otrzymaÅ‚ od " + sender.name + ": " + message);
				    }
				}

				// Client
				public class MediatorExample {
				    public static void main(String[] args) {
				        ChatMediator chat = new ChatRoom();

				        User user1 = new ChatUser(chat, "Jan");
				        User user2 = new ChatUser(chat, "Anna");
				        User user3 = new ChatUser(chat, "Kasia");

				        chat.addUser(user1);
				        chat.addUser(user2);
				        chat.addUser(user3);

				        user1.send("CzeÅ›Ä‡ wszystkim!");
				        user2.send("Hej Jan!");
				    }
				}

			ğŸ”¹ Wynik dziaÅ‚ania
				Jan wysyÅ‚a: CzeÅ›Ä‡ wszystkim!
				Anna otrzymaÅ‚ od Jan: CzeÅ›Ä‡ wszystkim!
				Kasia otrzymaÅ‚ od Jan: CzeÅ›Ä‡ wszystkim!

				Anna wysyÅ‚a: Hej Jan!
				Jan otrzymaÅ‚ od Anna: Hej Jan!
				Kasia otrzymaÅ‚ od Anna: Hej Jan!

			ğŸ”¹ Zalety Mediator
				- Redukuje zÅ‚oÅ¼onoÅ›Ä‡ relacji miÄ™dzy obiektami (luÅºne powiÄ…zanie).
				- UÅ‚atwia modyfikacjÄ™ logiki komunikacji (zmiana tylko w Mediatorze).
				- WiÄ™ksza przejrzystoÅ›Ä‡ systemu.



	8. Memento
		ğŸ”¹ Memento â€“ opis
			# Memento (pol. PamiÄ…tka) to wzorzec behawioralny, ktÃ³ry umoÅ¼liwia zapisywanie i przywracanie stanu obiektu bez naruszania jego enkapsulacji.
			ğŸ‘‰ Innymi sÅ‚owy:
				- MoÅ¼emy cofnÄ…Ä‡ siÄ™ do poprzedniego stanu obiektu (undo/rollback).
				- Stan obiektu jest przechowywany w specjalnym obiekcie Memento.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Czasami chcemy dodaÄ‡ moÅ¼liwoÅ›Ä‡ cofania operacji (np. edytor tekstu, gry, transakcje).
			# Nie chcemy ujawniaÄ‡ caÅ‚ej wewnÄ™trznej logiki obiektu (enkapsulacja).
			# RozwiÄ…zanie:
				- Tworzymy obiekt Memento, ktÃ³ry przechowuje stan.
				- Klasa Originator tworzy i odtwarza stan z Memento.
				- Klasa Caretaker zarzÄ…dza historiÄ… Memento (np. stos undo).

		ğŸ”¹ Struktura
			- Originator â€“ obiekt, ktÃ³rego stan zapisujemy.
			- Memento â€“ pamiÄ…tka przechowujÄ…ca stan.
			- Caretaker â€“ zarzÄ…dza historiÄ… Memento (np. przywraca wczeÅ›niejsze stany).

		ğŸ”¹ PrzykÅ‚ad w Javie
			# Scenariusz: prosty edytor tekstu z funkcjÄ… undo.
			# Kod
				import java.util.Stack;

				// Memento
				class TextMemento {
				    private final String state;

				    public TextMemento(String state) {
				        this.state = state;
				    }

				    public String getState() {
				        return state;
				    }
				}

				// Originator
				class TextEditor {
				    private String text = "";

				    public void write(String newText) {
				        text += newText;
				    }

				    public String getText() {
				        return text;
				    }

				    // Tworzy memento (snapshot)
				    public TextMemento save() {
				        return new TextMemento(text);
				    }

				    // Przywraca stan z memento
				    public void restore(TextMemento memento) {
				        text = memento.getState();
				    }
				}

				// Caretaker
				class History {
				    private Stack<TextMemento> history = new Stack<>();

				    public void save(TextEditor editor) {
				        history.push(editor.save());
				    }

				    public void undo(TextEditor editor) {
				        if (!history.isEmpty()) {
				            TextMemento memento = history.pop();
				            editor.restore(memento);
				        }
				    }
				}

				// Client
				public class MementoExample {
				    public static void main(String[] args) {
				        TextEditor editor = new TextEditor();
				        History history = new History();

				        editor.write("Hello");
				        history.save(editor);

				        editor.write(" World!");
				        history.save(editor);

				        System.out.println("Aktualny tekst: " + editor.getText());

				        history.undo(editor);
				        System.out.println("Po cofniÄ™ciu: " + editor.getText());

				        history.undo(editor);
				        System.out.println("Po kolejnym cofniÄ™ciu: " + editor.getText());
				    }
				}



	9. Iterator
	ğŸ”¹ Iterator â€“ opis
		- Iterator (pol. Iterator) to wzorzec behawioralny, ktÃ³ry umoÅ¼liwia sekwencyjny dostÄ™p do elementÃ³w kolekcji bez ujawniania jej wewnÄ™trznej struktury.
		- ğŸ‘‰ Innymi sÅ‚owy: Iterator pozwala przechodziÄ‡ po elementach np. listy, zbioru, tablicy, nie wiedzÄ…c jak kolekcja jest zaimplementowana.

	ğŸ”¹ Jaki problem rozwiÄ…zuje?
		- Bez Iteratora: trzeba znaÄ‡ szczegÃ³Å‚y struktury danych (np. tablica, lista, drzewo), Å¼eby jÄ… przeszukiwaÄ‡.
		- Iterator oddziela logikÄ™ przechodzenia od samej kolekcji.
		- UmoÅ¼liwia jednolity sposÃ³b iteracji po rÃ³Å¼nych typach kolekcji.
		- PrzykÅ‚ad Å¼ycia codziennego:
		- Czytasz ksiÄ…Å¼kÄ™ â€“ nie interesuje CiÄ™, jak kartki sÄ… wÅ‚oÅ¼one, po prostu przewracasz je jedna po drugiej.

	ğŸ”¹ Struktura
		- Iterator â€“ interfejs z metodami hasNext() i next().
		- ConcreteIterator â€“ implementacja iteratora dla konkretnej kolekcji.
		- Aggregate â€“ interfejs dla kolekcji, ktÃ³ra moÅ¼e udostÄ™pniaÄ‡ iterator.
		- ConcreteAggregate â€“ implementacja kolekcji.

	ğŸ”¹ PrzykÅ‚ad w Javie
		# Scenariusz: wÅ‚asna kolekcja z iteratorami.
		# Kod
			import java.util.ArrayList;
			import java.util.List;

			// Iterator
			interface MyIterator<T> {
			    boolean hasNext();
			    T next();
			}

			// Aggregate
			interface MyCollection<T> {
			    MyIterator<T> createIterator();
			}

			// ConcreteAggregate
			class MyList<T> implements MyCollection<T> {
			    private List<T> items = new ArrayList<>();

			    public void add(T item) {
			        items.add(item);
			    }

			    @Override
			    public MyIterator<T> createIterator() {
			        return new ListIterator();
			    }

			    // ConcreteIterator
			    private class ListIterator implements MyIterator<T> {
			        private int index = 0;

			        @Override
			        public boolean hasNext() {
			            return index < items.size();
			        }

			        @Override
			        public T next() {
			            return items.get(index++);
			        }
			    }
			}

			// Client
			public class IteratorExample {
			    public static void main(String[] args) {
			        MyList<String> list = new MyList<>();
			        list.add("Jan");
			        list.add("Anna");
			        list.add("Kasia");

			        MyIterator<String> iterator = list.createIterator();
			        while (iterator.hasNext()) {
			            System.out.println("Element: " + iterator.next());
			        }
			    }
			}

		ğŸ”¹ Zalety Iterator
			- Oddziela logikÄ™ iteracji od kolekcji â†’ zmiana struktury kolekcji nie wymaga zmiany klienta.
			- Jednolity interfejs do iteracji po rÃ³Å¼nych kolekcjach.
			- ObsÅ‚uguje rÃ³Å¼ne typy przeszukiwania (od poczÄ…tku do koÅ„ca, wstecz, filtrowanie itp.).


	10. Interpreter
		ğŸ”¹ Interpreter â€“ opis
			# Interpreter to wzorzec behawioralny, ktÃ³ry pozwala definiowaÄ‡ gramatykÄ™ jÄ™zyka i interpretowaÄ‡ zdania w tym jÄ™zyku.
			# KaÅ¼da reguÅ‚a gramatyki jest reprezentowana przez klasÄ™.
			# Obiekt interpretuje dane wejÅ›ciowe zgodnie z reguÅ‚ami.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			#  Potrzebujesz wÅ‚asnego jÄ™zyka, wyraÅ¼eÅ„ lub poleceÅ„, ktÃ³re program ma interpretowaÄ‡.
			#  Chcesz Å‚atwo dodawaÄ‡ nowe reguÅ‚y bez zmiany istniejÄ…cych klas.
			#  PrzykÅ‚ady:
				- Prosty kalkulator wyraÅ¼eÅ„ matematycznych.
				- Filtr w wyszukiwarce (price > 100 AND category = 'book').
				- MaÅ‚y jÄ™zyk skryptowy w aplikacji.

		ğŸ”¹ Struktura
			AbstractExpression â€“ interfejs lub klasa abstrakcyjna dla wszystkich wyraÅ¼eÅ„ (interpret).
			TerminalExpression â€“ klasy reprezentujÄ…ce elementy terminalne (np. liczby, literaÅ‚y).
			NonTerminalExpression â€“ klasy reprezentujÄ…ce reguÅ‚y gramatyki (np. operatory +, -, AND, OR).
			Context â€“ przechowuje dane potrzebne do interpretacji.

		ğŸ”¹ PrzykÅ‚ad w Javie
			// AbstractExpression
			interface Expression {
			    boolean interpret(int number);
			}

			// TerminalExpression: sprawdza czy liczba jest parzysta
			class EvenExpression implements Expression {
			    @Override
			    public boolean interpret(int number) {
			        return number % 2 == 0;
			    }
			}

			// TerminalExpression: sprawdza czy liczba jest wiÄ™ksza od okreÅ›lonej
			class GreaterThanExpression implements Expression {
			    private int limit;

			    public GreaterThanExpression(int limit) {
			        this.limit = limit;
			    }

			    @Override
			    public boolean interpret(int number) {
			        return number > limit;
			    }
			}

			// NonTerminalExpression: Å‚Ä…czy dwa wyraÅ¼enia operatorem AND
			class AndExpression implements Expression {
			    private Expression expr1;
			    private Expression expr2;

			    public AndExpression(Expression expr1, Expression expr2) {
			        this.expr1 = expr1;
			        this.expr2 = expr2;
			    }

			    @Override
			    public boolean interpret(int number) {
			        return expr1.interpret(number) && expr2.interpret(number);
			    }
			}

			// Client
			public class InterpreterExample {
			    public static void main(String[] args) {
			        Expression isEven = new EvenExpression();
			        Expression greaterThanTen = new GreaterThanExpression(10);
			        Expression evenAndGreaterThanTen = new AndExpression(isEven, greaterThanTen);

			        int[] numbers = {4, 11, 14, 9, 20};

			        for (int n : numbers) {
			            if (evenAndGreaterThanTen.interpret(n)) {
			                System.out.println(n + " speÅ‚nia warunek (parzysta i > 10)");
			            } else {
			                System.out.println(n + " nie speÅ‚nia warunku");
			            }
			        }
			    }
			}

		ğŸ”¹ Wynik dziaÅ‚ania
			4 nie speÅ‚nia warunku
			11 nie speÅ‚nia warunku
			14 speÅ‚nia warunek (parzysta i > 10)
			9 nie speÅ‚nia warunku
			20 speÅ‚nia warunek (parzysta i > 10)

		ğŸ”¹ Zalety Interpreter
			- ÅatwoÅ›Ä‡ dodawania nowych reguÅ‚ gramatyki.
			- Kod jest czytelny i modularny â€“ kaÅ¼da reguÅ‚a w osobnej klasie.
			- Naturalne odwzorowanie jÄ™zykÃ³w formalnych i prostych DSL (Domain Specific Language).

		ğŸ”¹ Wady
			- MoÅ¼e prowadziÄ‡ do duÅ¼ej liczby klas przy rozbudowanej gramatyce.
			- Nie zawsze efektywny dla bardzo duÅ¼ych wyraÅ¼eÅ„ â€“ wymaga optymalizacji.


	11. Visitor
		ğŸ”¹ Visitor â€“ opis
			# Visitor to wzorzec behawioralny, ktÃ³ry pozwala dodaÄ‡ nowe operacje do obiektÃ³w bez zmieniania ich klas.
			# Logika dziaÅ‚ania jest oddzielona od struktur obiektÃ³w.
			# Obiekt przyjmuje â€odwiedzajÄ…cegoâ€ (Visitor), ktÃ³ry wykonuje operacjÄ™ na jego danych.

		ğŸ”¹ Jaki problem rozwiÄ…zuje?
			# Masz hierarchiÄ™ klas, a chcesz dodaÄ‡ nowe operacje.
			# Nie chcesz modyfikowaÄ‡ wszystkich klas (zasada Open/Closed).
			# Typowe zastosowania:
				- raportowanie danych,
				- przetwarzanie drzew lub struktur zÅ‚oÅ¼onych,
				- serializacja obiektÃ³w.

		ğŸ”¹ Struktura
			# Visitor â€“ interfejs odwiedzajÄ…cego (visit dla kaÅ¼dej klasy elementu).
			# ConcreteVisitor â€“ implementacja operacji.
			# Element â€“ interfejs elementu, ktÃ³ry moÅ¼e zostaÄ‡ odwiedzony (accept).
			# ConcreteElement â€“ klasy implementujÄ…ce element.
			# ObjectStructure â€“ zbiÃ³r elementÃ³w, ktÃ³re mogÄ… byÄ‡ odwiedzane.

		ğŸ”¹ PrzykÅ‚ad w Javie
				// Visitor
				interface Visitor {
				    void visit(Book book);
				    void visit(Fruit fruit);
				}

				// ConcreteVisitor
				class PriceVisitor implements Visitor {
				    @Override
				    public void visit(Book book) {
				        System.out.println("KsiÄ…Å¼ka: " + book.getName() + " kosztuje " + book.getPrice() + " zÅ‚");
				    }

				    @Override
				    public void visit(Fruit fruit) {
				        System.out.println("Owoc: " + fruit.getName() + " kosztuje " + fruit.getPrice() + " zÅ‚");
				    }
				}

				// Element
				interface Item {
				    void accept(Visitor visitor);
				}

				// ConcreteElements
				class Book implements Item {
				    private String name;
				    private double price;

				    public Book(String name, double price) {
				        this.name = name;
				        this.price = price;
				    }

				    public String getName() { return name; }
				    public double getPrice() { return price; }

				    @Override
				    public void accept(Visitor visitor) {
				        visitor.visit(this);
				    }
				}

				class Fruit implements Item {
				    private String name;
				    private double price;

				    public Fruit(String name, double price) {
				        this.name = name;
				        this.price = price;
				    }

				    public String getName() { return name; }
				    public double getPrice() { return price; }

				    @Override
				    public void accept(Visitor visitor) {
				        visitor.visit(this);
				    }
				}

				// Client
				public class VisitorExample {
				    public static void main(String[] args) {
				        Item[] items = {
				            new Book("Java Podstawy", 50),
				            new Fruit("JabÅ‚ko", 3),
				            new Fruit("Banan", 4)
				        };

				        Visitor priceVisitor = new PriceVisitor();

				        for (Item item : items) {
				            item.accept(priceVisitor);
				        }
				    }
				}

		ğŸ”¹ Wynik dziaÅ‚ania
			KsiÄ…Å¼ka: Java Podstawy kosztuje 50.0 zÅ‚
			Owoc: JabÅ‚ko kosztuje 3.0 zÅ‚
			Owoc: Banan kosztuje 4.0 zÅ‚

		ğŸ”¹ Zalety Visitor
			- MoÅ¼liwoÅ›Ä‡ dodawania nowych operacji bez modyfikacji istniejÄ…cych klas.
			- Logika dziaÅ‚ania jest oddzielona od danych.
			- Przydatny przy pracy z drzewiastymi strukturami (Composite + Visitor).

		ğŸ”¹ Wady
			- Dodanie nowego typu elementu wymaga modyfikacji wszystkich VisitorÃ³w.
			- MoÅ¼e wprowadzaÄ‡ wiÄ™kszÄ… liczbÄ™ klas â€“ wzorzec bardziej przydatny przy duÅ¼ych strukturach.

